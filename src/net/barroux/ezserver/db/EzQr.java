package net.barroux.ezserver.db;

import static com.google.common.collect.Lists.newArrayList;
import static net.barroux.ezserver.db.DbHelper.conn;

import java.math.BigDecimal;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.Date;
import java.util.List;
import java.util.Map;

import org.apache.commons.dbutils.DbUtils;
import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.ResultSetHandler;
import org.apache.commons.dbutils.handlers.ArrayHandler;
import org.apache.commons.dbutils.handlers.ArrayListHandler;
import org.apache.commons.dbutils.handlers.BeanListHandler;
import org.apache.commons.dbutils.handlers.MapListHandler;
import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public final class EzQr {
	static final Logger log = LoggerFactory.getLogger(EzQr.class);
	private static final QueryRunner QR = new QueryRunner() {
		@Override
		protected void close(Connection conn) throws SQLException {
			try {
				DbUtils.close(conn);
			} catch (SQLException e) {
				log.warn("Could not close connexion", e);
			}
		}
	};

	private EzQr() {
	}

	public static int update(String sql, Object... params) {
		try {
			return QR.update(conn(), sql, params);
		} catch (SQLException e) {
			throw new DbException(e);
		}
	}

	public static Integer getInteger(String query, Object... params) {
		Object[] o = getArray(query, params);
		return o == null || o[0] == null ? null : ((BigDecimal) o[0])
				.intValue();
	}

	public static String getString(String query, Object... params) {
		Object[] o = getArray(query, params);
		return o == null || o[0] == null ? null : String.valueOf(o[0]);
	}

	public static Object[] getArray(String query, Object... params) {
		try {
			return QR.query(conn(), query, new ArrayHandler(),
					fixParams(params));
		} catch (SQLException e) {
			throw new DbException(e);
		}
	}

	public static <V> V query(String sql, ResultSetHandler<V> rsh,
			Object... params) {
		try {
			return QR.query(conn(), sql, rsh, params);
		} catch (SQLException s) {
			log.error("Error while executing request " + s.getMessage(), s);
			throw new DbException("Can't execute request " + sql, s);
		}
	}

	public static <V> List<V> queryAllRowsInListBean(Class<V> bean,
			String query, Object... params) {
		long start = new Date().getTime();
		List<V> obj = null;
		log.debug(query);
		try {
			// Use the BeanHandler implementation to convert the first
			// ResultSet row into a Person JavaBean.
			ResultSetHandler<List<V>> h = new BeanListHandler<V>(bean);
			// Execute the SQL statement with one replacement parameter and
			// return the results in a new Person object generated by the
			// BeanHandler.
			obj = QR.query(conn(), query, h, fixParams(params));
		} catch (SQLException e) {
			log.error("QueryAllRowsInListBean. Cant process query", e);
			throw new DbException("QueryAllRowsInListBean. Cant process query "
					+ query, e);
		}
		log.debug("queryAllRowsInListBean Execution Time : {}ms",
				(new Date().getTime() - start));
		return obj;
	}

	public static List<Object[]> queryAllInList(String query, Object... params) {
		long start = new Date().getTime();
		List<Object[]> obj = null;
		log.debug("--SELECT  : " + query);
		log.debug("--PARAMS-- : " + StringUtils.join(params, " , "));
		try {
			ResultSetHandler<List<Object[]>> h = new ArrayListHandler();
			obj = QR.query(conn(), query, h, fixParams(params));
		} catch (SQLException e) {
			log.error("queryAllInList - Cant process query", e);
			throw new DbException("queryAllInList - Cant process query "
					+ query, e);
		}
		log.debug("Execution Time :  {}ms", (new Date().getTime() - start));
		return obj;
	}

	/**
	 * Renvoie une liste d'Integer.
	 * 
	 * Pour que cela fonctionne, il faut que la première (et idéalement unique)
	 * colonne sélectionnée soit un nombre, et ne soit jamais nulle. Si une
	 * seule entrée est nulle, la méthode lancera une NullPointerException.
	 * 
	 * Idéalement conçue pour des requêtes d'id du type
	 * " SELECT STA_ID FROM GRT_ACTOR WHERE STA_TYPE='CDI' "
	 */
	public static List<Integer> queryAllInListOfInteger(String query,
			Object... params) {
		List<Object[]> objs = queryAllInList(query, params);
		List<Integer> result = newArrayList();
		for (Object[] ob : objs) {
			result.add(((BigDecimal) ob[0]).intValue());
		}
		return result;
	}

	/**
	 * Renvoie une liste de String.
	 * 
	 * Si une entrée est null, la liste contient une entrée null.
	 * 
	 */
	public static List<String> queryAllInListOfString(String query,
			Object... params) {
		List<Object[]> objs = queryAllInList(query, params);
		List<String> result = newArrayList();
		for (Object[] ob : objs) {
			String val = (String) ob[0];
			result.add((val != null ? val.toString() : null));
		}
		return result;
	}

	public static interface EzList extends List<Map<String, Object>> {

	};

	public static List<Map<String, Object>> queryAllInListOfMap(String query,
			Object... param) {
		long start = new Date().getTime();
		List<Map<String, Object>> obj = null;
		log.debug(query);
		try {
			obj = QR.query(conn(), query, new MapListHandler(),
					fixParams(param));
		} catch (SQLException e) {
			log.error("Cant process query", e);
			throw new DbException("Cant process query " + query, e);
		}
		log.debug("Execution Time :  {}ms", (new Date().getTime() - start));
		return obj;
	}

	public static <V> List<V> queryFixedNumberRowsInListBean(Class<V> bean,
			String query, int rowNumberMax) {

		return queryAllRowsInListBean(bean,
				addRowNumberCondition(query, rowNumberMax));
	}

	private static String addRowNumberCondition(String query, int rowNumberMax) {
		return "select * from ( " + query + ") where rownum<"
				+ Integer.toString(rowNumberMax);
	}

	public static int nextVal(String seqName) {
		return getInteger("SELECT " + seqName + ".nextval FROM DUAL");
	}

	/**
	 * Permet de faire des updates, deletes, insertes par batch.
	 * 
	 * Cette méthode peut être utilisée typiquement lorsque vous avez plusieurs
	 * requêtes identiques à effectuées avec juste des paramatres qui changent.
	 * JDBC compile la requête pour gagner en performance.
	 * 
	 * Cette méthode prend en paramètre un tableau contenant l'ensemble des
	 * tableaux de parametres. Par exemple : <BR>
	 * <ul>
	 * <li>[req1[param1, 'strg1']]</li>
	 * <li>[req2[param2, 'strg2']]</li>
	 * <li>etc..</li>
	 * 
	 * Cette méthode retourne un tableau d'entiers qui indique le nombres de
	 * lignes impactées par les requêtes. Ces valeurs sont retournées dans le
	 * même ordre que celui du tableau passé en paramètre.
	 * 
	 * @param query
	 * @param params
	 *            Tableau contenant les tableaux de paramètres pour la requête.
	 * @return Tableau contenant le nbre de ligne impactées pour chaque requête
	 *         éxécutée.
	 */
	public static int[] updateByBatch(String query, Object[][] params) {
		try {
			return QR.batch(conn(), query, params);
		} catch (SQLException e) {
			log.error("Cant process query", e);
			throw new DbException("Cant process query " + query, e);
		}
	}

	/**
	 * Transforme les java.util.Date en java.sql.Date et les Enumération en leur
	 * toString.
	 * 
	 * Le driver jdbc Oracle ne peut pas binder en paramètre de
	 * PreparedStatement des java.util.Date. Tout les paramètres qui ne sont pas
	 * des java.util.Date ou des enums sont laissés inchangés.
	 * 
	 * @param params
	 *            le tableau des paramètres à convertir.
	 * @return un nouveau tableau d'objet ne contenant plus de java.util.Date
	 */
	protected static Object[] fixParams(Object... params) {
		// Dbutils and jdbc won't handle properly java.util.Date as parameters :
		List<Object> fixedParams = newArrayList();
		for (Object o : params) {
			if (o instanceof Date)
				fixedParams.add(new java.sql.Timestamp(((Date) o).getTime()));
			else if (o != null && o.getClass().isEnum())
				fixedParams.add(o.toString());
			else
				fixedParams.add(o);
		}
		return fixedParams.toArray();
	}

}
